<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>íƒ€ì ì—°ìŠµ</title>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/simple-keyboard@latest/build/css/index.css"
    />
    <style>
      body {
        font-family: monospace;
        text-align: center;
      }
      #text-display {
        white-space: pre-wrap;
        font-size: 18px;
        margin: 20px auto;
        padding: 10px;
        background-color: lightgray;
        max-width: 600px;
        text-align: left;
        border-radius: 10px;
        overflow: hidden;
        height: 100px;
      }
      .correct {
        background-color: lightgreen;
      }
      .incorrect {
        background-color: lightcoral;
      }
      .keyboard-container {
        max-width: 600px;
        margin: auto;
      }
      .highlight-key {
        background-color: blue !important;
        color: white !important;
      }
      .pressed-key {
        background: rgb(218, 220, 228) !important;
      }
      .current-line {
        font-weight: bold;
      }
      .pending-line {
        color: gray;
      }
    </style>
  </head>
  <body>
    <h1>íƒ€ì ì—°ìŠµ</h1>
    <div id="score-display">
      <span id="accuracy">ì •í™•ë„: 0%</span> |
      <span id="cpm">CPM: 0</span>
    </div>
    <pre id="text-display"></pre>
    <div class="keyboard-container">
      <div class="simple-keyboard"></div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/simple-keyboard@latest/build/index.js"></script>
    <script>
      const textLines = [
        "#include <iostream>",
        "using namespace std;",
        "int main() {",
        '   cout << "Hello, World!" << endl;',
        "   return 0;",
        "}",
        "// This is a sample C++ program",
        "// It prints 'Hello, World!' to the console",
        "int add(int a, int b) {",
        "   return a + b;",
        "}",
        "void greet() {",
        '   cout << "Greetings!" << endl;',
        "}",
      ];

      const origin = textLines;

      let currentLineIndex = 0;
      let currentInput = "";
      const textDisplay = document.getElementById("text-display");
      const keyboard = new SimpleKeyboard.default({
        onChange: (input) => handleInput(input),
        onKeyPress: (button) => handleKeyPress(button),
        physicalKeyboardHighlight: true,
        layout: {
          default: [
            "` 1 2 3 4 5 6 7 8 9 0 - = {backspace}",
            "{tab} q w e r t y u i o p [ ] \\",
            "{capslock} a s d f g h j k l ; ' {enter}",
            "{shiftleft} z x c v b n m , . / {shiftright}",
            "{space}",
          ],
          shift: [
            "~ ! @ # $ % ^ & * ( ) _ + {backspace}",
            "{tab} Q W E R T Y U I O P { } |",
            '{capslock} A S D F G H J K L : " {enter}',
            "{shiftleft} Z X C V B N M < > ? {shiftright}",
            "{space}",
          ],
        },
        display: {
          "{tab}": "tab â‡¥",
          "{backspace}": "backspace âŒ«",
          "{enter}": "enter â†µ",
          "{capslock}": "caps lock â‡ª",
          "{shiftleft}": "shift â‡§",
          "{shiftright}": "shift â‡§",
          "{controlleft}": "ctrl âŒƒ",
          "{controlright}": "ctrl âŒƒ",
          "{space}": " ",
        },
        debug: true
      });

      let totalTyped = 0; // ì´ íƒ€ì ìˆ˜
      let correctTyped = 0; // ì •í™•íˆ ì…ë ¥í•œ ë¬¸ì ìˆ˜
      let startTime = null; // íƒ€ì´í•‘ ì‹œì‘ ì‹œê°„
      let cpmInterval = null; // CPM ê³„ì‚°ì„ ìœ„í•œ íƒ€ì´ë¨¸
      let result = null; // ê²°ê³¼ë¥¼ ì €ì¥í•  ê°ì²´
      let isCompleted = false; // ì…ë ¥ ì™„ë£Œ ì—¬ë¶€ë¥¼ ì¶”ì í•˜ëŠ” í”Œë˜ê·¸

      function updateScore() {
        const accuracy = totalTyped > 0 ? ((correctTyped / totalTyped) * 100).toFixed(2) : 100;
        const elapsedTime = (Date.now() - startTime) / 60000; // ê²½ê³¼ ì‹œê°„ (ë¶„ ë‹¨ìœ„)
        const cpm = elapsedTime > 0 ? Math.floor(totalTyped / elapsedTime) : 0;

        document.getElementById("accuracy").textContent = `ì •í™•ë„: ${accuracy}%`;
        document.getElementById("cpm").textContent = `CPM: ${cpm}`;
      }

      function startCPMTracking() {
        if (isCompleted) return; // ì…ë ¥ ì™„ë£Œ ìƒíƒœì—ì„œëŠ” íƒ€ì´ë¨¸ ì‹œì‘ ì¤‘ë‹¨

        if (!startTime) {
          startTime = Date.now(); // íƒ€ì´í•‘ ì‹œì‘ ì‹œê°„ ê¸°ë¡
        }
        if (!cpmInterval) {
          cpmInterval = setInterval(updateScore, 1000); // 1ì´ˆë§ˆë‹¤ ì ìˆ˜ ì—…ë°ì´íŠ¸
        }
      }

      function stopCPMTracking() {
        clearInterval(cpmInterval);
        cpmInterval = null;
      }

      function updateDisplay() {
        // ê¸°ì¡´ ë‚´ìš© ì´ˆê¸°í™”
        while (textDisplay.firstChild) {
          textDisplay.removeChild(textDisplay.firstChild);
        }

        // `text-display` ë†’ì´ì— ë”°ë¼ í‘œì‹œí•  ì¤„ ìˆ˜ ê³„ì‚°
        const lineHeight = 18; // í•œ ì¤„ì˜ ë†’ì´ (px, CSSì—ì„œ ì„¤ì •ëœ font-sizeì™€ ë™ì¼)
        const visibleLines = Math.floor(textDisplay.clientHeight / lineHeight); // í‘œì‹œ ê°€ëŠ¥í•œ ì¤„ ìˆ˜

        // í˜„ì¬ ì¤„ì„ ê¸°ì¤€ìœ¼ë¡œ í‘œì‹œí•  ì¤„ì˜ ë²”ìœ„ ê³„ì‚°
        const startLine = Math.max(0, currentLineIndex);
        const endLine = Math.min(startLine + visibleLines, textLines.length);

        for (let i = startLine; i < endLine; i++) {
          let lineElement = document.createElement("div");
          lineElement.className = i === currentLineIndex ? "current-line" : "pending-line";

          let textFragment = document.createDocumentFragment();

          textLines[i].split("").forEach((char, j) => {
            let span = document.createElement("span");
            span.textContent = char;
            if (i === currentLineIndex && j < currentInput.length) {
              span.className = char === currentInput[j] ? "correct" : "incorrect";
            }
            textFragment.appendChild(span);
          });

          lineElement.appendChild(textFragment);
          textDisplay.appendChild(lineElement);
        }

        // ìŠ¤í¬ë¡¤ ë™ì‘ ì œê±° (í•­ìƒ ê³ ì •ëœ ì¤„ í‘œì‹œ)
        textDisplay.scrollTop = 0;
      }

      function handleInput(input) {
        if (isCompleted) return; // ì…ë ¥ ì™„ë£Œ ìƒíƒœì—ì„œëŠ” ì¶”ê°€ ì²˜ë¦¬ ì¤‘ë‹¨

        startCPMTracking(); // íƒ€ì´í•‘ ì‹œì‘ ì‹œ CPM ì¶”ì  ì‹œì‘

        if (input.length < currentInput.length) {
          // Backspace ì…ë ¥ ì²˜ë¦¬
          const removedChar = currentInput[currentInput.length - 1];
          const expectedChar = textLines[currentLineIndex][currentInput.length - 1];

          if (removedChar === expectedChar) {
            correctTyped--; // ì •í™•íˆ ì…ë ¥í•œ ë¬¸ì ìˆ˜ ê°ì†Œ
          }
          totalTyped--; // ì´ íƒ€ì ìˆ˜ ê°ì†Œ
        } else {
          // ì¼ë°˜ ì…ë ¥ ì²˜ë¦¬
          totalTyped++; // íƒ€ì ìˆ˜ ì¦ê°€
          const currentChar = textLines[currentLineIndex][input.length - 1];
          const typedChar = input[input.length - 1];

          if (typedChar === currentChar) {
            correctTyped++; // ì •í™•íˆ ì…ë ¥í•œ ë¬¸ì ìˆ˜ ì¦ê°€
          }
        }

        currentInput = input;

        if (currentInput.length >= textLines[currentLineIndex].length) {
          currentLineIndex++;
          currentInput = "";

          // ë§ˆì§€ë§‰ ì¤„ê¹Œì§€ ì…ë ¥ ì™„ë£Œ ì‹œ ì²˜ë¦¬
          if (currentLineIndex >= textLines.length) {
            finalizeResult(); // ê²°ê³¼ ì €ì¥ ë° ê³„ì‚° ì¤‘ë‹¨
            return;
          }
        }

        updateDisplay();
        updateScore(); // ì ìˆ˜ ì—…ë°ì´íŠ¸
        keyboard.setInput(currentInput);
        highlightNextKey();
      }

      function finalizeResult() {
        // ì •í™•ë„ì™€ CPM ê°’ì„ result ê°ì²´ì— ì €ì¥
        const accuracy = totalTyped > 0 ? ((correctTyped / totalTyped) * 100).toFixed(2) : 100;
        const elapsedTime = (Date.now() - startTime) / 60000; // ê²½ê³¼ ì‹œê°„ (ë¶„ ë‹¨ìœ„)
        const cpm = elapsedTime > 0 ? Math.floor(totalTyped / elapsedTime) : 0;

        result = {
          accuracy: `${accuracy}%`, // ë¬¸ìì—´ë¡œ ì €ì¥
          cpm: cpm,                 // ìˆ«ìí˜•ìœ¼ë¡œ ì €ì¥
          totalTyped: totalTyped,   // ìˆ«ìí˜•ìœ¼ë¡œ ì €ì¥
        };

        // ê³„ì‚° ì¤‘ë‹¨
        stopCPMTracking();

        // ì…ë ¥ ì™„ë£Œ ìƒíƒœë¡œ ì„¤ì •
        isCompleted = true;

        // í™”ë©´ì— ê³ ì •ëœ ê°’ í‘œì‹œ
        document.getElementById("typed-count").textContent = `íƒ€ì ìˆ˜: ${result.totalTyped}`;
        document.getElementById("accuracy").textContent = `ì •í™•ë„: ${result.accuracy}`;
        document.getElementById("cpm").textContent = `CPM: ${result.cpm}`;

        console.log("Final Result:", result); // ë””ë²„ê¹…ìš© ì¶œë ¥
      }

      function calculateTotalScore() {
        // accuracyë¥¼ ìˆ«ìí˜•ìœ¼ë¡œ ë³€í™˜
        const numericAccuracy = parseFloat(result.accuracy); // "95.67%" -> 95.67
        const weightAccuracy = 0.7; // ì •í™•ë„ ê°€ì¤‘ì¹˜
        const weightCpm = 0.3;      // CPM ê°€ì¤‘ì¹˜

        // ì´ì  ê³„ì‚°
        const totalScore = (numericAccuracy * weightAccuracy) + (result.cpm * weightCpm);
        console.log(`ì´ì : ${totalScore.toFixed(2)}`);
        return totalScore;
      }

      function highlightNextKey() {
        let nextChar = textLines[currentLineIndex][currentInput.length] || "";
        document
          .querySelectorAll(".hg-button")
          .forEach((key) => key.classList.remove("highlight-key"));

        if (nextChar) {
          // íŠ¹ìˆ˜ ë¬¸ìë¥¼ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬í•˜ê¸° ìœ„í•´ CSS.escape() ì‚¬ìš©
          let keyElement = document.querySelector(
            `.hg-button[data-skbtn='${CSS.escape(nextChar)}']`
          );
          if (keyElement) keyElement.classList.add("highlight-key");
        }
      }

      function handleKeyPress(button) {
        let keyElement = document.querySelector(
          `.hg-button[data-skbtn='${CSS.escape(button)}']`
        );

        if (keyElement) {
          keyElement.classList.add("pressed-key");
          setTimeout(() => keyElement.classList.remove("pressed-key"), 200);

          if (
            button === "{shift}" ||
            button === "{shiftleft}" ||
            button === "{shiftright}" ||
            button === "{capslock}"
          )
            handleShift(button);
        }
      }

      function handleShift(button) {
        let currentLayout = keyboard.options.layoutName;
        let shiftToggle = currentLayout === "default" ? "shift" : "default";

        keyboard.setOptions({
          layoutName: shiftToggle,
        });

        let shiftKeyElement = document.querySelector(
          `.hg-button[data-skbtn='${button}']`
        );
        if (shiftKeyElement) {
          shiftKeyElement.classList.add("pressed-key");
        }

        setTimeout(() => {
          if (shiftKeyElement) {
            shiftKeyElement.classList.remove("pressed-key");
          }
        }, 200);
      }

      document.addEventListener("keydown", (event) => {
        // if (/[\u3131-\uD79D]/.test(event.key)) {
        //   alert("í•œê¸€ ì…ë ¥ì´ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.");
        // }

        if (event.key === "Tab") {
          event.preventDefault();
          handleInput(currentInput + "  ");
          return;
        }

        if (event.key === "Shift") {
          //shiftí‚¤ ëˆ„ë¥´ê³  ìˆì„ë•Œ
          keyboard.setOptions({ layoutName: "shift" });

          if (event.location === 1) {
            let shiftKeyElement = document.querySelector(
              `.hg-button[data-skbtn='{shiftleft}']`
            );
            if (shiftKeyElement) {
              shiftKeyElement.classList.add("pressed-key");
            }
          } else if (event.location === 2) {
            let shiftKeyElement = document.querySelector(
              `.hg-button[data-skbtn='{shiftright}']`
            );
            if (shiftKeyElement) {
              shiftKeyElement.classList.add("pressed-key");
            }
          }
        }

        if (event.key.length === 1 || event.key === "Backspace") {
          handleInput(
            event.key === "Backspace"
              ? currentInput.slice(0, -1)
              : currentInput + event.key
          );
        }
        let keyElement = document.querySelector(
          `.hg-button[data-skbtn='${CSS.escape(event.key)}']`
        );
        if (keyElement) {
          keyElement.classList.add("pressed-key");
        }
        
        if(!isCompleted)
          highlightNextKey();
      });

      document.addEventListener("keyup", (event) => {
        if (event.key === "Shift") {
          //shiftí‚¤ ì•ˆ ëˆ„ë¥¼ë•Œ
          keyboard.setOptions({ layoutName: "default" });
        }

        let keyElement = document.querySelector(
          `.hg-button[data-skbtn='${CSS.escape(event.key)}']`
        );
        if (keyElement) {
          keyElement.classList.remove("pressed-key");
        }
        if(!isCompleted)
          highlightNextKey();
      });

      updateDisplay();
      console.log(origin)

      // í˜ì´ì§€ë¥¼ ë– ë‚  ë•Œ íƒ€ì´ë¨¸ ì •ë¦¬
      window.addEventListener("beforeunload", stopCPMTracking);

      /*
      function startAutoTyping(username) {
        const easterEggUsername = "special_user"; // ì´ìŠ¤í„°ì—ê·¸ë¥¼ í™œì„±í™”í•  íŠ¹ì • ì‚¬ìš©ì ì´ë¦„

        if (username === easterEggUsername) {
          isCompleted = false; // ìë™ ì…ë ¥ ì‹œì‘ ì „ ì™„ë£Œ ìƒíƒœ ì´ˆê¸°í™”
          let autoTypingIndex = 0; // ìë™ ì…ë ¥ì„ ìœ„í•œ ì¸ë±ìŠ¤ ì´ˆê¸°í™”

          const autoTypingInterval = setInterval(() => {
            if (isCompleted || autoTypingIndex >= textLines.join("").length) {
              clearInterval(autoTypingInterval); // ìë™ ì…ë ¥ ì¢…ë£Œ
              finalizeResult(); // ê²°ê³¼ ì €ì¥ ë° ê³„ì‚° ì¤‘ë‹¨
              return;
            }

            // í˜„ì¬ ì…ë ¥í•  ê¸€ì ê°€ì ¸ì˜¤ê¸°
            const currentChar = textLines.join("")[autoTypingIndex];
            if (currentChar) {
              handleInput(currentInput + currentChar); // ê¸€ì ì¶”ê°€
              autoTypingIndex++; // ì¸ë±ìŠ¤ ì¦ê°€
            }
          }, 100); // 100ms ê°„ê²©ìœ¼ë¡œ ì…ë ¥ (ì†ë„ ì¡°ì • ê°€ëŠ¥)

          console.log("Easter Egg Auto Typing Activated! ğŸ‰");
        }
      }

      // ì˜ˆì‹œ: ì™¸ë¶€ì—ì„œ usernameì„ ë°›ì•„ ìë™ ì…ë ¥ ì‹œì‘
      const username = "special_user"; // ì™¸ë¶€ì—ì„œ ë°›ì•„ì˜¨ ì‚¬ìš©ì ì´ë¦„
      startAutoTyping(username);
      */
    </script>
  </body>
</html>
