<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>타자 연습</title>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/simple-keyboard@latest/build/css/index.css"
    />
    <style>
      body {
        font-family: monospace;
        text-align: center;
      }
      #text-display {
        white-space: pre-wrap;
        font-size: 18px;
        margin: 20px auto;
        padding: 10px;
        background-color: lightgray;
        max-width: 600px;
        text-align: left;
        border-radius: 10px;
        overflow: hidden;
        height: 100px;
      }
      .correct {
        background-color: lightgreen;
      }
      .incorrect {
        background-color: lightcoral;
      }
      .keyboard-container {
        max-width: 600px;
        margin: auto;
      }
      .highlight-key {
        background-color: blue !important;
        color: white !important;
      }
      .pressed-key {
        background: rgb(218, 220, 228) !important;
      }
      .current-line {
        font-weight: bold;
      }
      .pending-line {
        color: gray;
      }
    </style>
  </head>
  <body>
    <h1>타자 연습</h1>
    <div id="score-display">
      <span id="accuracy">정확도: 0%</span> |
      <span id="cpm">CPM: 0</span>
    </div>
    <pre id="text-display"></pre>
    <div class="keyboard-container">
      <div class="simple-keyboard"></div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/simple-keyboard@latest/build/index.js"></script>
    <script>
      const textLines = [
        "#include <iostream>",
        "using namespace std;",
        "int main() {",
        '   cout << "Hello, World!" << endl;',
        "   return 0;",
        "}",
        "// This is a sample C++ program",
        "// It prints 'Hello, World!' to the console",
        "int add(int a, int b) {",
        "   return a + b;",
        "}",
        "void greet() {",
        '   cout << "Greetings!" << endl;',
        "}",
      ];

      const origin = textLines;

      let currentLineIndex = 0;
      let currentInput = "";
      const textDisplay = document.getElementById("text-display");
      const keyboard = new SimpleKeyboard.default({
        onChange: (input) => handleInput(input),
        onKeyPress: (button) => handleKeyPress(button),
        physicalKeyboardHighlight: true,
        layout: {
          default: [
            "` 1 2 3 4 5 6 7 8 9 0 - = {backspace}",
            "{tab} q w e r t y u i o p [ ] \\",
            "{capslock} a s d f g h j k l ; ' {enter}",
            "{shiftleft} z x c v b n m , . / {shiftright}",
            "{space}",
          ],
          shift: [
            "~ ! @ # $ % ^ & * ( ) _ + {backspace}",
            "{tab} Q W E R T Y U I O P { } |",
            '{capslock} A S D F G H J K L : " {enter}',
            "{shiftleft} Z X C V B N M < > ? {shiftright}",
            "{space}",
          ],
        },
        display: {
          "{tab}": "tab ⇥",
          "{backspace}": "backspace ⌫",
          "{enter}": "enter ↵",
          "{capslock}": "caps lock ⇪",
          "{shiftleft}": "shift ⇧",
          "{shiftright}": "shift ⇧",
          "{controlleft}": "ctrl ⌃",
          "{controlright}": "ctrl ⌃",
          "{space}": " ",
        },
        debug: true
      });

      let totalTyped = 0; // 총 타자 수
      let correctTyped = 0; // 정확히 입력한 문자 수
      let startTime = null; // 타이핑 시작 시간
      let cpmInterval = null; // CPM 계산을 위한 타이머
      let result = null; // 결과를 저장할 객체
      let isCompleted = false; // 입력 완료 여부를 추적하는 플래그

      function updateScore() {
        const accuracy = totalTyped > 0 ? ((correctTyped / totalTyped) * 100).toFixed(2) : 100;
        const elapsedTime = (Date.now() - startTime) / 60000; // 경과 시간 (분 단위)
        const cpm = elapsedTime > 0 ? Math.floor(totalTyped / elapsedTime) : 0;

        document.getElementById("accuracy").textContent = `정확도: ${accuracy}%`;
        document.getElementById("cpm").textContent = `CPM: ${cpm}`;
      }

      function startCPMTracking() {
        if (isCompleted) return; // 입력 완료 상태에서는 타이머 시작 중단

        if (!startTime) {
          startTime = Date.now(); // 타이핑 시작 시간 기록
        }
        if (!cpmInterval) {
          cpmInterval = setInterval(updateScore, 1000); // 1초마다 점수 업데이트
        }
      }

      function stopCPMTracking() {
        clearInterval(cpmInterval);
        cpmInterval = null;
      }

      function updateDisplay() {
        // 기존 내용 초기화
        while (textDisplay.firstChild) {
          textDisplay.removeChild(textDisplay.firstChild);
        }

        // `text-display` 높이에 따라 표시할 줄 수 계산
        const lineHeight = 18; // 한 줄의 높이 (px, CSS에서 설정된 font-size와 동일)
        const visibleLines = Math.floor(textDisplay.clientHeight / lineHeight); // 표시 가능한 줄 수

        // 현재 줄을 기준으로 표시할 줄의 범위 계산
        const startLine = Math.max(0, currentLineIndex);
        const endLine = Math.min(startLine + visibleLines, textLines.length);

        for (let i = startLine; i < endLine; i++) {
          let lineElement = document.createElement("div");
          lineElement.className = i === currentLineIndex ? "current-line" : "pending-line";

          let textFragment = document.createDocumentFragment();

          textLines[i].split("").forEach((char, j) => {
            let span = document.createElement("span");
            span.textContent = char;
            if (i === currentLineIndex && j < currentInput.length) {
              span.className = char === currentInput[j] ? "correct" : "incorrect";
            }
            textFragment.appendChild(span);
          });

          lineElement.appendChild(textFragment);
          textDisplay.appendChild(lineElement);
        }

        // 스크롤 동작 제거 (항상 고정된 줄 표시)
        textDisplay.scrollTop = 0;
      }

      function handleInput(input) {
        if (isCompleted) return; // 입력 완료 상태에서는 추가 처리 중단

        startCPMTracking(); // 타이핑 시작 시 CPM 추적 시작

        if (input.length < currentInput.length) {
          // Backspace 입력 처리
          const removedChar = currentInput[currentInput.length - 1];
          const expectedChar = textLines[currentLineIndex][currentInput.length - 1];

          if (removedChar === expectedChar) {
            correctTyped--; // 정확히 입력한 문자 수 감소
          }
          totalTyped--; // 총 타자 수 감소
        } else {
          // 일반 입력 처리
          totalTyped++; // 타자 수 증가
          const currentChar = textLines[currentLineIndex][input.length - 1];
          const typedChar = input[input.length - 1];

          if (typedChar === currentChar) {
            correctTyped++; // 정확히 입력한 문자 수 증가
          }
        }

        currentInput = input;

        if (currentInput.length >= textLines[currentLineIndex].length) {
          currentLineIndex++;
          currentInput = "";

          // 마지막 줄까지 입력 완료 시 처리
          if (currentLineIndex >= textLines.length) {
            finalizeResult(); // 결과 저장 및 계산 중단
            return;
          }
        }

        updateDisplay();
        updateScore(); // 점수 업데이트
        keyboard.setInput(currentInput);
        highlightNextKey();
      }

      function finalizeResult() {
        // 정확도와 CPM 값을 result 객체에 저장
        const accuracy = totalTyped > 0 ? ((correctTyped / totalTyped) * 100).toFixed(2) : 100;
        const elapsedTime = (Date.now() - startTime) / 60000; // 경과 시간 (분 단위)
        const cpm = elapsedTime > 0 ? Math.floor(totalTyped / elapsedTime) : 0;

        result = {
          accuracy: `${accuracy}%`, // 문자열로 저장
          cpm: cpm,                 // 숫자형으로 저장
          totalTyped: totalTyped,   // 숫자형으로 저장
        };

        // 계산 중단
        stopCPMTracking();

        // 입력 완료 상태로 설정
        isCompleted = true;

        // 화면에 고정된 값 표시
        document.getElementById("typed-count").textContent = `타자 수: ${result.totalTyped}`;
        document.getElementById("accuracy").textContent = `정확도: ${result.accuracy}`;
        document.getElementById("cpm").textContent = `CPM: ${result.cpm}`;

        console.log("Final Result:", result); // 디버깅용 출력
      }

      function calculateTotalScore() {
        // accuracy를 숫자형으로 변환
        const numericAccuracy = parseFloat(result.accuracy); // "95.67%" -> 95.67
        const weightAccuracy = 0.7; // 정확도 가중치
        const weightCpm = 0.3;      // CPM 가중치

        // 총점 계산
        const totalScore = (numericAccuracy * weightAccuracy) + (result.cpm * weightCpm);
        console.log(`총점: ${totalScore.toFixed(2)}`);
        return totalScore;
      }

      function highlightNextKey() {
        let nextChar = textLines[currentLineIndex][currentInput.length] || "";
        document
          .querySelectorAll(".hg-button")
          .forEach((key) => key.classList.remove("highlight-key"));

        if (nextChar) {
          // 특수 문자를 안전하게 처리하기 위해 CSS.escape() 사용
          let keyElement = document.querySelector(
            `.hg-button[data-skbtn='${CSS.escape(nextChar)}']`
          );
          if (keyElement) keyElement.classList.add("highlight-key");
        }
      }

      function handleKeyPress(button) {
        let keyElement = document.querySelector(
          `.hg-button[data-skbtn='${CSS.escape(button)}']`
        );

        if (keyElement) {
          keyElement.classList.add("pressed-key");
          setTimeout(() => keyElement.classList.remove("pressed-key"), 200);

          if (
            button === "{shift}" ||
            button === "{shiftleft}" ||
            button === "{shiftright}" ||
            button === "{capslock}"
          )
            handleShift(button);
        }
      }

      function handleShift(button) {
        let currentLayout = keyboard.options.layoutName;
        let shiftToggle = currentLayout === "default" ? "shift" : "default";

        keyboard.setOptions({
          layoutName: shiftToggle,
        });

        let shiftKeyElement = document.querySelector(
          `.hg-button[data-skbtn='${button}']`
        );
        if (shiftKeyElement) {
          shiftKeyElement.classList.add("pressed-key");
        }

        setTimeout(() => {
          if (shiftKeyElement) {
            shiftKeyElement.classList.remove("pressed-key");
          }
        }, 200);
      }

      document.addEventListener("keydown", (event) => {
        // if (/[\u3131-\uD79D]/.test(event.key)) {
        //   alert("한글 입력이 감지되었습니다.");
        // }

        if (event.key === "Tab") {
          event.preventDefault();
          handleInput(currentInput + "  ");
          return;
        }

        if (event.key === "Shift") {
          //shift키 누르고 있을때
          keyboard.setOptions({ layoutName: "shift" });

          if (event.location === 1) {
            let shiftKeyElement = document.querySelector(
              `.hg-button[data-skbtn='{shiftleft}']`
            );
            if (shiftKeyElement) {
              shiftKeyElement.classList.add("pressed-key");
            }
          } else if (event.location === 2) {
            let shiftKeyElement = document.querySelector(
              `.hg-button[data-skbtn='{shiftright}']`
            );
            if (shiftKeyElement) {
              shiftKeyElement.classList.add("pressed-key");
            }
          }
        }

        if (event.key.length === 1 || event.key === "Backspace") {
          handleInput(
            event.key === "Backspace"
              ? currentInput.slice(0, -1)
              : currentInput + event.key
          );
        }
        let keyElement = document.querySelector(
          `.hg-button[data-skbtn='${CSS.escape(event.key)}']`
        );
        if (keyElement) {
          keyElement.classList.add("pressed-key");
        }
        
        if(!isCompleted)
          highlightNextKey();
      });

      document.addEventListener("keyup", (event) => {
        if (event.key === "Shift") {
          //shift키 안 누를때
          keyboard.setOptions({ layoutName: "default" });
        }

        let keyElement = document.querySelector(
          `.hg-button[data-skbtn='${CSS.escape(event.key)}']`
        );
        if (keyElement) {
          keyElement.classList.remove("pressed-key");
        }
        if(!isCompleted)
          highlightNextKey();
      });

      updateDisplay();
      console.log(origin)

      // 페이지를 떠날 때 타이머 정리
      window.addEventListener("beforeunload", stopCPMTracking);
    </script>
  </body>
</html>
